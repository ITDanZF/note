# 1.树

## 树的基本性质

1. ：<font color='red'>结点的度：</font>结点拥有子树的个数

2. ：<font color='red'>树的度：</font> 树内各结点中度数的最大值

3. ：<font color='red'>树的深度：</font>树中最大的层数为树的深度或高度

4. ：<font color='red'>森林：</font>多棵互不相交的树的集合

5. ：<font color='red'>对任意的树，满足该恒等式：</font>*非根节点的孩子结点数 +1（根节点）= 树的结点总数*

## 树的存储结构

1. 双亲表示法：用一组连续的存储单元来存储树的结点，结点之间相邻存储，每个结点包含有data数据域以及parent域，parent域用于存储父结点的位置
2. 孩子表示法：又称多重链表，由于每个结点都可能有个子树，所以每个结点都含有一个data数据域以及多个指针域，指针域用于指向其子树的根结点
3. 孩子兄弟表示法（二叉树表示法）：用二叉链表作为树的存储结构

#### 树的三种存储结构的特点对比

> ①：双亲表示法：利用“每个结点都有唯一的双亲”的特点来存储树，可以方便的寻找结点的双亲和树根，但是寻找孩子结点时需要遍历整个结构
>
> ②：孩子表示法：这种存储方式便于寻找孩子结点，但是寻找双亲结点不方便
>
> ③：孩子兄弟表示法：该存储结构优点在于方便实现树和二叉树的相互转换，缺点是查找双亲结点不太方便（可以增设一个parent指针域解决）

## 二叉树的性质

1. ：<font color='red'>二叉树中第i层的最大结点数（假设根节点为第一层）：</font>$2^{i-1}$

2. ：<font color='red'>深度为K的二叉树最大结点数（深度为k的满二叉树）：</font>$2^k-1$

3. ：<font color='red'>任意二叉树，满足该恒等式：</font>$n_0=n_2+1$

4. ：<font color='red'>二叉树中结点的编号：</font> *结点编号为$\lceil {i \over 2} \rceil$,其左孩子结点为i,结点i的左孩子为2i,结点i的右孩子为2i+1*

5. ：<font color='red'>n个结点的二叉树，其空指针域的个数（二叉树上的线索数）：</font>$n+1$

6. ：<font color='red'>满二叉树：</font>深度为k且含有$2^k-1$个结点的二叉树
7. ：<font color='red'>满二叉树的特点：</font>满二叉树的结点个数一定是奇数

8. ：<font color='red'>完全二叉树：</font>深度为k且含有n个结点的二叉树，当且仅当每个结点都与深度为K的满二叉树的编号从1~n一一对应
9. ：<font color='red'>完全二叉树的特点：</font>完全二叉树的总结点数为奇数时，树中没有度为1的结点。只有完全二叉树的总结点数为偶数时，树中才有度为1的结点。

10. ：<font color='red'>n个结点的完全二叉树深度：</font>$\lfloor log_2(n) \rfloor+1$

11. ：<font color='red'>n个结点的完全二叉树叶子结点：</font>$\lceil {n \over 2} \rceil$

12. ：<font color='red'>正则二叉树（严格二叉树，又称哈夫曼树）：</font>二叉树中任意一个结点，要么只是度为0叶子节点，要么是恰好有两个子树的非叶子结点（任意结点的度只能是0或2）。
13. ：<font color='red'>哈夫曼树的结点总数，叶子结点数，非叶子结点数的关系：</font>哈夫曼树的结点总数是奇数，其中当叶子结点数为n时,非叶子节点数为$n-1$，结点总数为$2n-1$个

14. ：<font color='red'>高度为h的哈夫曼树：</font>哈夫曼树的高度h等于其叶子节点数，进一步得知：非叶子结点数为h-1,结点总数为$2h-1$
15. ：<font color='red'>哈夫曼树的叶子结点：</font>用于构造哈夫曼树的所有结点，即成为哈夫曼树的所有叶子节点，其数量上是相等的。
16. ：<font color='red'>森林的遍历序列和所对应二叉树的遍历序列之间的关系：</font>森林的前序遍历，中序遍历以及后序遍历和所对应二叉树的遍历序列相同

## 二叉树的存储结构

①：顺序存储结构

②：链式存储结构

*链式存储结构：二叉链表，三叉链表，线索链表*

*二叉链表：含有n个结点的二叉链表有$n+1$个空指针域，而这些空指针域可用于存储线索*

*两种存储结构的对比：对于完全二叉树更适合顺序存储结构，对于一般的二叉树而言，采用顺序存储会造成空间的极大浪费，所以链式存储结构更适合一般二叉树*

```c++
typedef struct {
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode,*BiTree
```

## 遍历二叉树

##### 遍历二叉树：按照某种搜索的顺序访问树中的任意结点，而且每个节点只能被访问一次

#####  遍历的方法：层序遍历，先序遍历，中序遍历，后序遍历

1. 层序遍历：按照树的编号顺序，自上而下，从左到右的方向访问树中的每个结点
2. 先序遍历（根左右）：先遍历子树的根，接着遍历左子树，最后遍历右子树
3. 中序遍历（左根右）：先遍历左子树，接着遍历子树的根节点，最后遍历右子树
4. 后序遍历（左右根）：先遍历左子树，接着遍历右子树，最后遍历子树的根节点

## 线索二叉树

遍历二叉树就是以一定的规则将非线性结构的二叉树给排列成一个线性序列，而在线性序列中为了更方便访问某结点前驱和后继的相关信息，利用n个结点的二叉树中必有$n+1$个空指针域特点，用这些空指针域来存储前驱和后继的相关信息

##### 标志域：用于判断指针域是否指向孩子或者前驱后继结点

LTag=0：指针域指向左孩子结点  | LTag=1：指针域指向前驱结点

RTag=0: 指针域指向右孩子结点   | RTag=1：指针域指向后继节点 



## 树与森林的相互转换

##### 1. 树转换为二叉树：保留每个子树的左孩子结点，其余孩子结点断开指针，然后横向画线，然后顺时针旋转45度到右孩子的位置（若结点有只有一个孩子结点（垂直方向），直接旋转作为左孩子结点）

##### 2. 森林转换为二叉树：将森林中每一颗树分别转换为二叉树，然后将每一棵树根横向拼接并顺时针旋转45度

##### 3. 二叉树转换为森林

## 题型

1. #### 完全二叉树按顺序编号，已知完全二叉树的最后一个非叶子结点的编号为n,请问该完全二叉树的叶子结点数以及总结点数？

> ①：情况1：当完全二叉树结点个数最多时，结点总数为$2n+1$,叶子总数为$2n+1 - n = n+1$
>
> ②：情况2：当完全二叉树结点个数最少时，结点总数为$2n$,叶子总数为$2n - n = n$

2. #### 给出二叉树的前序遍历序列和后序遍历序列，可以从中得出什么信息？

> 只给出二叉树的前序遍历和后序遍历虽然不能确认一棵完整的二叉树，但是可以得到 该二叉树的*根结点*和*根结点的所有孩子结点*
>
> 如：
>
> ①：前序遍历：<font color='red'>A</font><font color='blue'>B</font>DECF,后序遍历：DEBF<font color='blue'>C</font><font color='red'>A</font> ；根结点为<font color='red'>A</font>，根结点的孩子结点为<font color='blue'>B</font>和<font color='blue'>C</font>
>
> ②：前序遍历：<font color='red'>A</font><font color='blue'>B</font>DEC,后序遍历：DCE<font color='blue'>B</font><font color='red'>A</font>； 根结点为<font color='red'>A</font>，根结点的孩子结点为<font color='blue'>B</font>

3. #### 已知森林有m个边数，n个结点，则森林中含有多少棵树？

> 当森林里有一颗树时候，有$m1$个边数，就有$m1+1$个结点，当森林里有两棵树时，有$m1+m2$个边数，就有$m1+m2+2$个结点
>
> 当森林里有$i$棵树时，边数: $m = m1 + m2 + m3 +...+mi$, 结点数：$n=m1+m2+...+mi + i$
>
> 则森林里的i棵树：
>
> $i = n - m $
>
> *森林里树的数量为森林的结点数减去边数*

# 2.图

## 基本概念

1. <font color='red'>无向完全图：</font>任意两个点之间都有一条边相连，即完全图的边数为 $n(n-1) \over 2$
2. <font color='red'>有向完全图：</font>任意两点之间都有两条边相连，即有向完全图的边数为 $n(n-1)$
3. <font color='red'>弧：</font>有向图的中带箭头的边
4. <font color='red'>稀疏图：</font>图的边数或弧数很少的图，若顶点数为n的图，其边数小于 $nlog_{2}{n}$，那么就可以称为稀疏图
5. <font color='red'>稠密图：</font>边数或弧数很多的图
6. <font color='red'>网：</font>边或弧上带有权值的图称为网
7. <font color='red'>邻接：</font>任意两点之间是否有边或弧相连，若有相连则这两个顶点邻接，不相连则这两个顶点不邻接，相邻接的两个顶点称为邻接点
8. <font color='red'>顶点的边：</font>与该顶点相关联的边的数目
9. <font color='red'>有向图边的顶点：</font>有向图的顶点有出度和入度
10. <font color='red'>路径：</font>图中从顶点$v_1$到顶点$v_n$所经过的顶点序列（由连续的边构成的顶点序列）
11. <font color='red'>路径长度：</font>一条路径所经过的边或弧 他数量
12. <font color='red'>简单路径，简单回路，简单环路：</font>某路径的顶点序列中不重复出现
13. <font color='red'>连通：</font>若在无向图中，两顶点之间存在路径使其相连，那么这两顶点连通
14. <font color='red'>连通图：</font>无向图G中任意两个顶点都是连通的，那么图G就是连通图
15. <font color='red'>连通分量：</font>无向图G的极大连通子图（顶点数最大，即加入新的顶点后图不再连通）
16. <font color='red'>强连通图：</font>在有向图G中，两个顶点的两个方向都有路径使其连通
17. <font color='red'>强连通分量：</font>有向图中的极大强连通子图
18. <font color='red'>极小连通子图：</font>用最少的边数使得该子图连通
19. <font color='red'>连通图的生成树：</font>包含无向图G中所有顶点的极小连通子图
20. <font color='red'>有向树：</font>仅有一个顶点的入度为0，其余顶点的入度均为1的图
21. <font color='red'>生成森林：</font>各个连通分量的生成树集合

 

## 图的存储结构

### 顺序存储结构（数组表示法）

图的邻接矩阵（有向图和无向图）

1. 无向图的邻接矩阵是个实对称矩阵，该矩阵对角元素都为0，其余元素为1时表示对应的两个顶点是连通的，其余元素为0时表示两个顶点是不连通的，<font color='red'>矩阵的行和或列和为对应顶点的度</font>
2. 有向图的邻接矩阵可能是非实对称矩阵，而完全有向图的矩阵一定是对称矩阵，规定$(v_i,v_j)$表示矩阵i行第j列的元素，若第$(v_i,v_j)=1$表示有一条从顶点$v_i$到顶点$v_j$的有向边，若$(v_i, v_j)=0$表示顶点$v_i$和顶点$v_j$没有边， <font color='red'>另外矩阵的行和为对应顶点的出度数，矩阵的列和为对用顶点的入度数</font>>

网的邻接矩阵（带权图的邻接矩阵）

1. 无向网的邻接矩阵是对称矩阵，性质与无向图的邻接矩阵类似，矩阵的取值一般为实数或无穷，实数表示两点之间边的权值大小，无穷表示两点没有边相连，对应的权值也就无穷大
2. 有向网的邻接矩阵可能是非对称矩阵，性质与上述类似

### 链式存储结构

邻接表

> 无向图邻接表
>
> 1. 每一行单链表的结点个数为该顶点的度 
> 2. 邻接表不唯一，空间复杂度为$O(n+2e)$
> 3. 所有链表的结点数为图中边数的两倍
>
> 有向图邻接表
>
> 1. 每一行单链表的结点个数为该顶点的出度或入度（取决于按照入边还是出边构建邻接表）
> 2. 空间复杂度为$O(n+e)$
> 3. 所有链表的结点数为图中边数

十字链表

邻接多重表

## 图的遍历

### 深度优先搜索遍历

> 定义数组Visited[m]，用于记录已被访问的结点
>
> 1. 访问一个结点，并在数组中标记该节点
> 2. 找出与之相关联的所有结点，并访问其中一个
> 3. 若所有相关联的结点已被标记过，则回退上一个结点
> 4. 重复上述步骤

### 广度优先搜索遍历

> 定义队列Queue作为辅助队列
>
> 1. 访问起始结点，起始结点入队
> 2. 接着访问起始结点相连的所有结点，并将这些结点入队
> 3. 与起始结点相关联结的所有结点全部访问完毕，则起始结点出队
> 4. 队列中的下一个结点作为队头，并继续访问该结点的相关连结点，接着入队
> 5. 重复上述操作

## 图的应用

#### 1. 图的生成树（无回路的连通图）

n个顶点的图由n-1条边保持连通，并且没有回路

##### 深度优先生成树

> 对图G使用深度优先搜索方法进行遍历，生成的遍历图称为深度优先生成树

##### 广度优先生成树

> 对图G使用广度优先搜索方法进行遍历，生成的遍历图称为广度优先生成树

##### 最小生成树（只对带权图来说）

在带权图的生成树中，所有边上的权值之和为最小的生成树

> 普里姆算法
>
> 克鲁斯卡尔算法

